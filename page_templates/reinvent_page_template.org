#+LATEX_CLASS: ramsay-org-article
#+LATEX_CLASS_OPTIONS: [oneside,A4paper,12pt]
#+AUTHOR: Ramsay Leung
#+EMAIL: ramsayleung@gmail.com
#+DATE: 2025-04-14 Mon 22:59
#+OPTIONS: author:nil ^:{} H:4
#+HUGO_BASE_DIR: ~/code/org/ramsayleung.github.io
#+HUGO_SECTION: zh/post/2025
#+HUGO_CUSTOM_FRONT_MATTER: :toc true
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DRAFT: false
#+DATE: [2025-04-14 Mon 22:59]
#+TITLE: 重新造轮子系列(五)：模板引擎
#+HUGO_TAGS: reinvent
#+HUGO_CATEGORIES: "ReInvent: 重新造轮子系列"
项目 GitHub 地址: [[https://github.com/ramsayleung/reinvent/tree/master/page_templates][Page Template]]
* 前言
  在现代网站开发里，内容与表现的分离已经成为基本准则(Separation of content and presentation),
  比如 HTML 就是负责内容展现，而 CSS 就是负责页面的样式。

  而手动更新和编写 HTML 也是一件费时费力并且容易出错的工作，尤其是需要同时修改多个页面的时候，
  因此有聪明的程序员就发明了名为静态网页生成器(static site generator)的技术，可以按需生成网页。

  事实上，互联网上的大多数页面都是通过某种形式的静态网页生成器生成出来的。

  而静态网页生成器的核心就是「模板引擎」，在过去三十年，诞生过无数的模板引擎，
  甚至有位加拿大的程序员为了更方便记录谁访问了他的简历，他还发明了一门编程语言来做模板引擎的活，这就是「世界上最好的编程语言：PHP」。

  PHP 可以算是 Web时代的王者之一，凭借着 =LAMP(Linux, Apache, MySql, PHP)= 架构不断开疆扩土，攻城掠地，而PHP本身也不断有新的框架被造出来，为谁是最好的「模板引擎」打得头破血流。

  虽然关于「模板引擎」的战争至今仍未停歇，但细分下来，「模板引擎」可以分成三个主要的流派：
** 嵌入式语法
   在 Markdown/HTML 这样的标识语言里面嵌入编程语言，使用 =<% %>= 等符号来标记代码与文本内容，其中的代表包括 Javascript 的 [[https://ejs.co/][EJS]], Ruby 的 [[https://docs.ruby-lang.org/en/2.3.0/ERB.html][ERB]], 以及 Python 的 [[https://jinja.palletsprojects.com/en/stable/][Jinja]]:
   #+begin_src js
     <!-- 用特殊标记混合JavaScript与HTML -->
     <% if (user) { %>
       <h1><%= user.name %></h1>
     <% } %>
   #+end_src

   其优点就是可以直接使用嵌入的编程语言，功能强大，学习成本低，缺点就是模板很容易变成混杂内容和逻辑的「屎山」代码
** 自定义语法
   不嵌入现成的编程语言，而是自己开发一套 mini 编程语言，或者叫 DSL(domain specifc language), 代表有 [[https://pages.github.com/][GitHub Page]] 用到的 [[https://jekyllrb.com/][Jekyll]], 还有 Golang 开发的著名静态网页生成器 [[https://gohugo.io/][Hugo]], 都是使用自定义的语法：
   #+begin_src golang
     {% comment %} 自创模板语法 {% endcomment %}
     {% for post in posts %}
       {{ post.title | truncate: 30 }}
     {% endfor %}
   #+end_src

   优点就是语法简洁，缺点就是发展下去，可以又是自己造了一个新的编程语言，功能还不如通用的编程语言强大
** HTML指令
   不再在 HTML 中嵌入编程语言或DSL，取而代之的是直接给 HTML 定义特定的属性，不同的属性代表不同的含义，但是使用的还是标准 HTML.

   最著名的就是 [[https://vuejs.org/][Vuejs]]:
   #+begin_src html
     <!-- 用特殊属性实现逻辑 -->
     <div v-if="user">
       <h1>{{ user.name }}</h1>
     </div>
   #+end_src

   优点是保持HTML的合法性与简洁，不需要额外的 parser, 缺点就是指令功能受限，不如内嵌编程语言强大，生态工具较少, 灵活性差。

   本文的模板引擎就会以这个流派为范式进行开发。
** 特例之PHP
   分析完三种流派，就会奇怪 PHP 究竟是属于哪个流派呢？

   #+begin_src php
     <h1><?php echo $title; ?></h1>
     <ul>
       <?php foreach ($items as $item) { ?>
         <li><?php echo $item; ?></li>
       <?php } ?>
     </ul>
   #+end_src

   其实 PHP 本质就是流派二，只是这门专门用于「模板引擎」的 mini 语言，最后演化成了一门专门的编程语言，只是这个编程语言最擅长的还是网页开发，即是做「模板引擎」。

   所以 PHP 是从流派二演化成流派一。
* 目标
  可能不是所有的朋友都了解 Vue，所以在设计我们的模板引擎之前，先来明确一下需求与目标(scope).

  假设我们有如下的 JSON 数据:
  #+begin_src js
    {
        names: ['Johnson', 'Vaughan', 'Jackson']
    }
  #+end_src

  如果有如下的模板:
  #+begin_src html
    <html>
      <body>
        <p>Expect three items</p>
        <ul z-loop="item:names">
          <li><span z-var="item"/></li>
        </ul>
      </body>
    </html>
  #+end_src

  那么 =names= 就会被赋值给 =item=, 然后每一个变量都会被展开成 =<span>{item}</span>=, 所以上面的模板就会被展开成:
  #+begin_src html
    <html>
      <body>
        <p>Expect three items</p>
        <ul>
          <li><span>Johnson</span></li>
          <li><span>Vaughan</span></li>
          <li><span>Jackson</span></li>
        </ul>
      </body>
    </html>
  #+end_src

  而不同的指令会有不同的效果，如上的 =z-loop= 就是遍历一个数组，而 =z-if= 就是判断一个变量是否为 =true=, 为 =true= 则输出，否则则不输出.

  如有数据:
  #+begin_src js
    {
        "showThis": true,
        "doNotShowThis": false
    }
  #+end_src

  和模板:
  #+begin_src html
    <html>
      <body>
        <p z-if="showThis">This should be shown.</p>
        <p z-if="doNotShowThis">This should <em>not</em> be shown.</p>
      </body>
    </html>
  #+end_src

  就会被渲染成:
  #+begin_src html
    <html>
      <body>
        <p>This should be shown.</p>
      </body>
    </html>
  #+end_src

  本文支持的指令集可见下文.
* 设计思路
** stack frame
   模板引擎的核心是将「数据」+「模板」渲染成页面，那么数据要如何保存呢？以什么数据结构和变量形式来处理呢？

   最简单的方式肯定就是使用全局变量的 HashMap 来保存所有的变量，但是如果存在两个同名的变量，那么 HashMap 这种数据结构就不适用。

   更何况，可变的全局变量可谓是万恶之源，不知道有多少 bug 都是源自可变的全局变量。

   在编译原理，保存变量的标准做法就是使用 stack frame, 每次进入一个函数就创建一个新的栈(=stack=), 每次函数调用都有自己的独立的栈，可以理解成每个栈就是一个 =HashMap=, 而每创建一个栈就是向 =List= 里面 =push= 一个新的 =HashMap=, 同一个函数里面不能有同名的变量，那能保证栈里面的值是唯一。
   
   [[file:../img/reinvent_stack_frame.jpg]]

   谈及变量和 stack frame, 编程语言中有个 =作用域(scoping)= 的概念, 定义了变量会怎么被程序访问到。

   主要有两种作用域，分别被称为：

   词法作用域([[https://en.wikipedia.org/wiki/Scope_(computer_science)][Lexical/Static Scoping]]): 在编译时就将变量给解析确定了下来，大部分编程语言使用的都是语法作用域，比如 Javascript, C/C++, Rust, Golang, Swift, Java 这个名单还可以很长.

   因为其性能更优，并且行为是相当明确的，不需要分析运行时代码再来确定，如：

   #+begin_src javascript
     let x = 10; // 全局变量

     function foo() {
       console.log(x); // 词法作用域，问题绑定全局变量 x 
     }

     function bar() {
       let x = 20; // 局部变量，不会影响 foo 中的 x 
       foo(); // 调用 foo(), 仍然需要访问全局变量
     }

     foo(); // 输出: 10 (全局变量)
     bar(); // 输出: 10 (还是全局变量，而非局部变量)
   #+end_src

   
  另外一种作用域是动态作用域(Dynamic Scoping): 在运行时通过遍历调用栈来确定变量的值，现在已经很少有编程语言使用了，比如是 Perl4, Bash, 或者是 Emacs Lisp:
  #+begin_src bash
    #!/bin/bash

    x="global"

    foo() {
      echo "$x"  # x 的值取决于谁来调用 `foo`, 运行时决定
    }

    bar() {
      local x="local"  # 动态作用域: 会影响 foo 的值
      foo
    }

    foo  # 输出: "global" (x 是全局变量)
    bar  # 输出: "local"  (x 是 bar 函数的局部变量)
  #+end_src

  也就是 =foo= 中 =x= 的值还取决于调用方的栈，因为在 =bar= 里面调用 =foo= 时， bash 解释器会把 =bar= 的栈一并传给 =foo=, 所以 =foo= 就以最近栈中 =x= 的值为准。

  这种作用域实现方式虽然简单，但是对于程序员 debug 来说简直是噩梦，所以在现代编程语言基本绝迹了。

  话虽如此，但是对于模板引擎而言，动态作用域却是主流选择，主要是因为：
  1. 模板的特性需求：循环/条件语句需要运行时创建临时变量
  2. 隔离性要求：避免不同模板间的变量污染
  3. 异常处理：未定义变量可返回 =undefined/null= 而非报错
   
  因此我们的模板引擎也会使用动态作用域来保存变量，即 =List<HashMap<String, String>>= 的数据结构.
** vistor pattern
** 接口设计
* 实现
** 支持的指令集
** 示例
  [[file:../reinvent_project.org][回到本系列的目录]]
